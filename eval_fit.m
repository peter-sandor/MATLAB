function FIT_out = eval_fit(FIT)
% This function calculates statistical variables for the fits generated by
% the 'ezfit' function.
% Input: FIT - struct that contains the fitted data and fit parameters.
%               This is the output of 'ezfit(...)'.
% Output: FIT_out - this struct contains the same information as the input
%               FIT, but more: sigma2, chi2, reduced chi2 and the
%               covariance matrix for fitted parameters, 'B' is calculated.

% source for statistical analysis:
% Bevington, Robinson: Data Reduction and Error Analysis for the Physical Sciences
% Zoltan Szatmari: Bevezetes a Meresek Kiertekelesebe (Introduction to Data Analysis, BUTE lecture notes)

% First create symbolic variables and calculate the symbolic derivatives of
% the model fit function as a function of fit parameters.
ind_eq=strfind(FIT.name,'=');
fit_eq=FIT.name(ind_eq+1:end);
syms('x');
for ind1=1:length(FIT.param)
    syms(FIT.param{ind1})
end

x=FIT.x;
y=FIT.y;
y_sigma=FIT.dy;
N=length(y);
Nc=length(FIT.param);

fnct = sym(fit_eq);
for ind1=1:length(FIT.param)
    dfnct(ind1)=diff(fnct,FIT.param{ind1});
    if strcmp(char(dfnct(ind1)),'1')
        str_dfnct{ind1}='ones([1 N])';
    else
        str_dfnct{ind1}=char(dfnct(ind1));
    end
end

% In the next part, numerically evaluate the fitted function and its derivatives for each data
% point 'x', using numerical values for the fitted parameters.
% N-Nc will be the degrees of freedom for the fit.
for ind1=1:length(FIT.param)
    eval([FIT.param{ind1} '=' num2str(FIT.m(ind1)) ';']); % Calculate numerical values for parameters
    eval(['F(ind1,:)=' put_array_ops(str_dfnct{ind1}) ';']); % Evaluate derivatives numerically --> matrix 'F'
end

% evaluate function numerically --> array 'y_fit'
eval(['y_fit=' put_array_ops(fit_eq) ';']);
FIT_out=FIT;
% Calculate sigma^2
FIT_out.sigma2=sum((y-y_fit).^2)/(N-Nc);
% Calculate covariance matrix 'B' for fitted parameters
weights = 1./y_sigma.^2/sum(1./y_sigma.^2);
W=diag(weights);
R_inv=F*W*F.';
FIT_out.B=FIT_out.sigma2*inv(R_inv);
% Calculate chi2 and reduced chi2
FIT_out.chi2=sum(((y-y_fit)./y_sigma).^2);
FIT_out.chi2_red=FIT_out.chi2/(N-Nc);

%% calculate F-value
terms = separate_terms(x,y,FIT.eq,FIT.param,FIT.m);
terms_mean=mean(extend(map2colvec(weights),size(terms,2)).*terms,1);
% calculate sample covariance and multiple correlation coefficient R2
FIT_out.R2=0;
y_mean=mean(weights.*y);
FIT_out.B_y=1/(N-1)*sum((y-y_mean).^2);
for ind1=1:size(terms,2)
    for ind2=1:size(terms,2)
        FIT_out.B_sample(ind1,ind2) = N/(N-1)*sum(map2colvec(weights).*(terms(:,ind1)-terms_mean(ind1)).*(terms(:,ind2)-terms_mean(ind2)));
    end
    FIT_out.B_ym(ind1) = sum(map2colvec(weights).*(terms(:,ind1)-terms_mean(ind1)).*map2colvec((y-y_mean)));
    if ind1>1
        FIT_out.R2 = FIT_out.R2 + FIT_out.m(ind1)*FIT_out.B_ym(ind1);
    end
end
FIT_out.R2 = FIT_out.R2/FIT_out.B_y;
FIT_out.F = FIT_out.R2*(N-Nc)/(1-FIT_out.R2)/(Nc-1);
end